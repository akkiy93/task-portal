# 開発ワークフローガイド: AIアシスタント + Cursor Bugbot活用

## 概要

このガイドでは、AIアシスタント（Auto）とCursor Bugbotを活用した効率的な開発ワークフローを説明します。

## 基本ワークフロー

### 1. 機能実装フェーズ

#### ステップ1: 実装計画の確認
```
ユーザー: 「○○機能を実装したい」
AI: 実装計画を提案・確認
```

#### ステップ2: 実装
- AIがコードを実装
- 必要に応じて段階的に実装・確認

#### ステップ3: ローカルテスト
- ブラウザで動作確認
- エラーがあれば修正

### 2. リファクタリングフェーズ

#### ステップ1: リファクタリング対象の特定
```bash
# AIに依頼
「リファクタリングをお願いします」
```

#### ステップ2: AIによるリファクタリング
- コードの重複を削減
- 共通関数の抽出
- 可読性の向上
- パフォーマンスの最適化

#### ステップ3: 動作確認
- リファクタリング後も動作することを確認

### 3. バグチェックフェーズ

#### ステップ1: ローカルでの確認
- 手動テスト
- ブラウザのコンソールでエラー確認

#### ステップ2: Git操作とプルリクエスト作成
```bash
# 変更をコミット
git add .
git commit -F commit_msg.txt

# プッシュ
git push origin feature/branch-name

# GitHubでプルリクエストを作成
```

#### ステップ3: Cursor Bugbotによる自動レビュー
- プルリクエスト作成時に自動実行
- バグや問題を検出
- コメントで指摘

#### ステップ4: Bugbotの指摘を修正
```bash
# Bugbotが指摘した問題を修正
# AIに依頼: 「Bugbotの指摘を修正してください」

# 修正をコミット
git add .
git commit -F commit_msg.txt
git push origin feature/branch-name
```

### 4. GitHub操作フェーズ

#### ステップ1: ブランチの作成
```bash
# 新しい機能用ブランチを作成
git checkout -b feature/issue-XX-description
```

#### ステップ2: 変更のコミット
```bash
# UTF-8エンコーディングでコミットメッセージを作成
# AIが自動的にcommit_msg.txtを作成・使用

git add .
git commit -F commit_msg.txt
```

#### ステップ3: プッシュ
```bash
git push origin feature/branch-name
```

#### ステップ4: プルリクエスト作成
- GitHubのWeb UIでプルリクエストを作成
- Cursor Bugbotが自動レビューを実行

#### ステップ5: Issueの対応
```bash
# Issueにコメントを追加
gh issue comment XX --body-file comment.txt

# Issueをクローズ
gh issue close XX
```

## 実践的な手順例

### 例1: 新機能の実装からマージまで

1. **実装**
   ```
   ユーザー: 「○○機能を実装してください」
   AI: 実装を開始
   ```

2. **リファクタリング**
   ```
   ユーザー: 「リファクタリングをお願いします」
   AI: コードを改善
   ```

3. **Git操作**
   ```bash
   git add .
   git commit -F commit_msg.txt
   git push origin feature/xxx
   ```

4. **プルリクエスト作成**
   - GitHubでPR作成
   - Cursor Bugbotが自動レビュー

5. **Bugbotの指摘を修正**
   ```
   ユーザー: 「Bugbotの指摘を修正してください」
   AI: 修正を実施
   ```

6. **再プッシュ**
   ```bash
   git add .
   git commit -F commit_msg.txt
   git push origin feature/xxx
   ```

7. **マージ**
   - PRをマージ
   - Issueをクローズ

### 例2: バグ修正のワークフロー

1. **バグの報告**
   ```
   ユーザー: 「○○でエラーが発生します」
   ```

2. **原因の特定**
   ```
   AI: コードを確認して原因を特定
   ```

3. **修正**
   ```
   AI: バグを修正
   ```

4. **テスト**
   - 動作確認

5. **Git操作**
   ```bash
   git add .
   git commit -F commit_msg.txt
   git push origin feature/bugfix-xxx
   ```

6. **PR作成とBugbotレビュー**
   - PR作成
   - Bugbotが問題を検出（もしあれば）

7. **修正とマージ**

## AIアシスタントへの依頼例

### リファクタリング
```
「リファクタリングをお願いします」
「コードの重複を削減してください」
「共通関数を抽出してください」
```

### バグ修正
```
「Bugbotの指摘を修正してください」
「このエラーを修正してください: [エラーメッセージ]」
```

### Git操作
```
「変更をコミットしてプッシュしてください」
「Issue #XXの対応をお願いします」
「プルリクエストを作成してください」
```

### コードレビュー
```
「このコードに問題がないか確認してください」
「パフォーマンスを改善してください」
```

## Cursor Bugbotの活用ポイント

### Bugbotが検出する問題
- 未使用変数
- 未初期化変数
- 型の不一致
- 実行フローの問題（return文の欠落など）
- 潜在的なnull参照
- メモリリークの可能性

### Bugbotの指摘への対応
1. **指摘を確認**: PRのコメントを確認
2. **AIに依頼**: 「Bugbotの指摘を修正してください」
3. **修正を確認**: 修正内容を確認
4. **再プッシュ**: 修正をコミット・プッシュ

## ベストプラクティス

### 1. 小さなコミット
- 1つのコミットで1つの変更
- コミットメッセージを明確に

### 2. 定期的なリファクタリング
- 機能追加後はリファクタリングを検討
- コードの品質を維持

### 3. Bugbotの指摘を必ず確認
- 自動レビューを活用
- 指摘があれば必ず対応

### 4. テストの実施
- 実装後は必ず動作確認
- Bugbotの指摘修正後も再確認

### 5. Issue管理
- 実装完了後はIssueにコメント
- 完了したIssueはクローズ

## トラブルシューティング

### Bugbotが指摘しない場合
- 問題がない可能性
- または、Bugbotが検出できない問題の可能性
- 手動でのコードレビューも重要

### コミットメッセージの文字化け
- `commit_msg.txt`を使用（UTF-8エンコーディング）
- AIが自動的に作成・使用

### プルリクエストのコンフリクト
- ベースブランチを最新に更新
- `git rebase`または`git merge`で解決

## まとめ

このワークフローを活用することで：
- ✅ 効率的な開発
- ✅ 高品質なコード
- ✅ 早期のバグ検出
- ✅ スムーズなGit操作

AIアシスタントとCursor Bugbotを組み合わせることで、開発の効率と品質を大幅に向上させることができます。

